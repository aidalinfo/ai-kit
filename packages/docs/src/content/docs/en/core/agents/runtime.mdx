---
title: Agent runtime
description: Share binary resources and mutable state between AI Kit tools
sidebar:
  order: 6
locale: en-US
---

The agent runtime provides a request-scoped mutable store to share data between application code and the tools executed by the model. It replaces direct use of `experimental_context` and avoids injecting file paths into prompts.

## Initialize a runtime

```ts
import { Agent, RuntimeStore } from "@ai_kit/core";

const runtime = new RuntimeStore<{ workbook: Workbook }>();
runtime.set("workbook", await loadWorkbookFromBase64(payload));
runtime.onCleanup("workbook", (workbook) => workbook?.destroy());

const assistant = new Agent({
  name: "assistant-ops",
  model: scaleway("gpt-oss-120b"),
});

const result = await assistant.generate({
  prompt: "Analyze the `Summary` sheet and suggest two KPIs.",
  runtime,
});
```

- `RuntimeStore` accepts typed values (`RuntimeStore<{ workbook: Workbook }>`). The `get`, `set`, `require`, and `delete` methods behave like a `Map`.
- `onCleanup` registers a function automatically called at the end of the request (including when streaming).
- The runtime is automatically cloned for each call. You can reuse the same instance across requests without leaking state.

## Access the runtime in a tool

```ts
import { createRuntimeTool } from "@ai_kit/core";
import { z } from "zod";

const previewSheet = createRuntimeTool({
  id: "excel.preview",
  description: "Returns a preview of an already-loaded XLSX sheet",
  inputSchema: z.object({ sheet: z.string() }),
  async execute({ sheet }, { runtime }) {
    const workbook = runtime.require<Workbook>("workbook");
    const data = extractPreview(workbook, sheet);
    return { rows: data.slice(0, 5) };
  },
});

const assistant = new Agent({
  name: "assistant-xlsx",
  model: scaleway("gpt-oss-120b"),
  tools: { previewSheet },
});
```

`createRuntimeTool` automatically injects the runtime into the `execute` signature. If no runtime is available (for example if the caller forgets `runtime`), execution fails immediately.

## Load declarative resources

```ts
import { registerRuntimeResource } from "@ai_kit/core";

registerRuntimeResource("excelWorkbook", {
  async loader(source: string, runtime) {
    const buffer = Buffer.from(source, "base64");
    const workbook = await ExcelJS.Workbook.fromBuffer(buffer);
    runtime.set("workbook", workbook);
    return workbook;
  },
  dispose(workbook) {
    workbook?.destroy();
  },
});

await runtime.load("excelWorkbook", payload.base64);
```

`registerRuntimeResource` centralizes encode/decode logic and guarantees consistent cleanup via `dispose`. `runtime.load` invokes the loader, stores the value, and triggers cleanup automatically after the response.

## Tips and best practices

- **Asynchronous isolation:** every `generate` or `stream` call runs inside an `AsyncLocalStorage` context. Tools can retrieve the current runtime without extra parameters.
- **Streaming:** in streaming mode, the runtime remains active until the stream closes. Registered cleanups run as soon as the generation ends or an error occurs.
- **Multiple runtimes:** instantiate multiple `RuntimeStore`s to separate functional domains (e.g. `fileRuntime`, `userRuntime`). Simply pass the relevant instance to `assistant.generate`.
- **Advanced typing:** by parameterizing `RuntimeStore<{ ... }>` and `createRuntimeTool<INPUT, OUTPUT, RuntimeState>`, TypeScript ensures the available keys and types stay in sync inside your tools.
