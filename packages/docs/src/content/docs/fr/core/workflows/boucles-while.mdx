---
title: Boucles while
description: Répéter une même étape jusqu'à satisfaire une condition, sans perdre l'historique.
sidebar:
  order: 3
locale: fr-FR
---

`createWhileStep` encapsule une boucle contrôlée : vous fournissez une condition, un `maxIterations` obligatoire et l'étape à répéter. L'API s'occupe d'enchaîner les exécutions, de transmettre l'output précédent comme nouvel input et de collecter les résultats.

## Exemple de polling

Le snippet suivant interroge un service tant que le statut n'est pas `"ready"` ou que la limite d'itérations n'est pas atteinte.

```ts
import {
  createMapStep,
  createWhileStep,
  createWorkflow,
} from "@ai_kit/core";
import { z } from "zod";

const pollingStateSchema = z.object({
  jobId: z.string().min(1),
  attempt: z.number().int().min(0),
  done: z.boolean().optional(),
});

type PollingState = z.infer<typeof pollingStateSchema>;
type PollingResult = PollingState & { done: boolean };

const checkStatus = createMapStep<PollingState, PollingResult>({
  id: "check-status",
  inputSchema: pollingStateSchema,
  outputSchema: pollingStateSchema.extend({
    done: z.boolean(),
  }),
  handler: async ({ input }) => {
    const attempt = input.attempt;

    const done = await fetch(`/jobs/${input.jobId}/status?attempt=${attempt}`)
      .then(res => res.json())
      .then(body => body.done === true);

    return {
      jobId: input.jobId,
      attempt: attempt + 1,
      done,
    };
  },
});

const pollUntilDone = createWhileStep({
  id: "poll-job",
  description: "Relance checkStatus jusqu'à completion ou timeout",
  inputSchema: z.object({
    jobId: z.string().min(1),
    attempt: z.number().int().min(0).default(0),
  }),
  loopStep: checkStatus,
  maxIterations: 12,
  condition: ({ lastOutput }) => {
    // Continue tant que le service n'est pas prêt (12 tentatives max)
    return lastOutput?.done !== true;
  },
});

export const pollWorkflow = createWorkflow({
  id: "polling",
  inputSchema: z.object({
    jobId: z.string().min(1),
    attempt: z.number().int().min(0).default(0),
  }),
  outputSchema: z.object({
    lastResult: pollingStateSchema.extend({ done: z.boolean() }).optional(),
    allResults: z.array(pollingStateSchema.extend({ done: z.boolean() })),
  }),
})
  .while(pollUntilDone)
  .commit();
```

Par défaut, le step retourne `{ lastResult, allResults }` avec `lastResult` potentiellement `undefined` si aucune itération n'a eu lieu. Ici nous nous appuyons sur ce comportement standard, ce qui suffit pour exposer l'état final et l'historique complet. `maxIterations` reste obligatoire et déclenche un `WorkflowExecutionError` si la condition voudrait poursuivre au-delà de la limite : l'UI peut ainsi afficher un message explicite.

## Condition & garde-fous

- La fonction `condition({ input, lastOutput, iteration, context, signal })` est évaluée avant chaque itération. Retournez `false` pour sortir de la boucle proprement.
- `maxIterations` protège contre les boucles infinies : si la condition resterait vraie après avoir atteint cette limite, une erreur est levée avec l'identifiant du step.
- L'abort signal est propagé automatiquement : si `signal.aborted === true`, la boucle s'interrompt avec `WorkflowAbortError`.

## Préparer l'input et collecter les résultats

- `prepareNextInput` est optionnel. Sans lui, l'input initial est passé lors de la première itération puis chaque output devient l'input suivant, comme dans l'exemple ci-dessus. Utilisez ce hook uniquement si vous devez transformer explicitement l'input.
- `collect` reçoit `{ input, results, lastResult, iterations, context }` et vous laisse façonner la sortie (aggregation, mapping vers une structure métier). Si vous ne le fournissez pas, `createWhileStep` renvoie `{ lastResult, allResults }`.

## ForEach ou While ?

- `createForEachStep` itère sur une collection connue d'avance et peut paralléliser le traitement (`concurrency`). Idéal pour transformer des listes ou agréger des tâches indépendantes.
- `createWhileStep` s'utilise lorsqu'on ne connaît pas le nombre d'itérations à l'avance : polling, workflow de validation, raffinements successifs où chaque output conditionne la suite.
- Vous pouvez combiner les deux : par exemple, un `while` qui poll des tâches en file d'attente et, une fois le feu vert obtenu, un `forEach` qui distribue le travail sur chaque item.

Besoin d'un contrôle conditionnel explicitement ramifié ? Consultez la page [`Branches conditionnelles`](./branches-conditionnelles).
